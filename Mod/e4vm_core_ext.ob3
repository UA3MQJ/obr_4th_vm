MODULE e4vm_core_ext;
IMPORT SYSTEM, C := Console, Platform, B := Basic,

e4vm_type, e4vm_utils;

(*# нет операции *)
PROCEDURE quit* (VAR v: e4vm_type.x4thPtr);
BEGIN
  (* B.Quit; *) (* вроде бы не работает*)
END quit;


(*# Чтобы при интерпретации отличить числовую константу от адреса слова,
  # при компиляции перед каждой константой компилируется вызов слова doLit,
  # которое считывает следующее значение в памяти и размещает его на стеке данных.*)
PROCEDURE do_lit* (VAR v: e4vm_type.x4thPtr);
BEGIN
  (* C.WriteStrLn("do_lit!"); *)
  v.ip := v.ip + 1;
  e4vm_utils.stack_ds_push(@v, v.mem[v.ip]);  
END do_lit;


(*# поместит в стек данных адрес hereP.*)
PROCEDURE get_here_addr* (VAR v: e4vm_type.x4thPtr);
BEGIN
  e4vm_utils.stack_ds_push(@v, v.hereP);
END get_here_addr;


(*# Reserve data space for one cell and store w in the space.
  # просто положит в ячейку на hereP++ число из стека *)
PROCEDURE comma* (VAR v: e4vm_type.x4thPtr);
BEGIN
  (* C.WriteStrLn("comma"); *)
  v.ds_p := v.ds_p - 1;
	e4vm_utils.add_op(@v, v.ds[v.ds_p]);
END comma;

(*# переход по адресу в следующей ячейке *)
PROCEDURE branch* (VAR v: e4vm_type.x4thPtr);
BEGIN
  v.ip := v.mem[v.ip + 1] - 1;
END branch;

(*# переход по адресу, если в топ ds 0. то есть false.
  # false - это все биты в ноле. true - это все биты одной ячейки(cell) в единице. *)
PROCEDURE zbranch* (VAR v: e4vm_type.x4thPtr);
BEGIN
  v.ds_p := v.ds_p - 1;
  IF v.ds[v.ds_p] = 0 THEN
    v.ip := v.mem[v.ip + 1] - 1;
  ELSE
    v.ip := v.ip;
  END
END zbranch;

BEGIN
   
END e4vm_core_ext.